{
  "name": "lavalink",
  "version": "2.13.0",
  "description": "A Lavalink client for JavaScript.",
  "main": "dist/src/index.js",
  "types": "typings/src/index.d.ts",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/lavalibs/lavalink.js.git"
  },
  "author": "Will Nelson <will@pleb.xyz>",
  "maintainers": [
    "DevYukine <devyukine@gmx.de>"
  ],
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/lavalibs/lavalink.js/issues"
  },
  "homepage": "https://github.com/lavalibs/lavalink.js#readme",
  "devDependencies": {
    "@spectacles/gateway": "^0.10.0",
    "@spectacles/types": "^0.2.1",
    "@types/backoff": "^2.5.1",
    "@types/ws": "^6.0.4",
    "env-cmd": "^10.1.0",
    "rimraf": "^3.0.2",
    "typescript": "^4.1.2"
  },
  "dependencies": {
    "backoff": "^2.5.0",
    "ws": "^7.4.0"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start:dev": "pnpm prepare && env-cmd .env node --trace-warnings dist/test/index.js",
    "start:cluster": "pnpm prepare && env-cmd .env node --trace-warnings dist/test/cluster.js"
  },
  "readme": "# Lavalink.js\n\n[![Lavalink.js support server](https://discordapp.com/api/guilds/494948120103485440/embed.png)](https://discord.gg/jXSKeW5)\n\nA JavaScript wrapper for the [Lavalink](https://github.com/freyacodes/Lavalink) audio client for Discord. Only supports Lavalink v3; use 0.7.x for Lavalink v2. For a queue implementation, check out [lavaqueue](https://github.com/appellation/lavaqueue).\n\n## Getting started\n\n```js\nconst { Node } = require('lavalink');\n\nconst voice = new Node({\n  password: '', // your Lavalink password\n  userID: '', // the user ID of your bot\n  shardCount: 0, // the total number of shards that your bot is running (optional, useful if you're load balancing)\n  hosts: {\n    rest: '', // the http host of your lavalink instance (optional)\n    ws: '', // the ws host of your lavalink instance (optional)\n  },\n  host: '', // a URL to your lavalink instance without protocol (optional, can be used instead of specifying hosts option)\n  send(guildID, packet) {\n    // send this packet to the gateway\n    // you are responsible for properly serializing and encoding the packet for transmission\n    return gateway.connections.get(Long.fromString(guildID).shiftRight(22).mod(this.shardCount)).send(packet);\n  },\n});\n```\n\nYou must also forward pre-decoded `VOICE_STATE_UPDATE` and `VOICE_SERVER_UPDATE` packets to the library by calling the `voiceStateUpdate` and `voiceServerUpdate` methods respectively.\n\n```js\ngateway.on('VOICE_STATE_UPDATE', (shard, state) => voice.voiceStateUpdate(state)); // forward voice state updates\ngateway.on('VOICE_SERVER_UPDATE', (shard, info) => voice.voiceServerUpdate(info)); // forward voice server updates\ngateway.on('GUILD_CREATE', (shard, guild) => {\n  for (const state of guild.voice_states) voice.voiceStateUpdate(state);\n});\n```\n\n> All examples that use the `gateway` variable are based off of the [Spectacles Gateway](https://github.com/spec-tacles/gateway.js) API, but any gateway library can be used as long as you can send and receive raw data to/from the Discord API.\n\n## Basic operation\n\nPlayers are available in a map keyed by guild ID, and are always available: if no player has yet been generated for a guild, it will be created.\n\n```js\nconst player = voice.players.get('a guild id');\n```\n\nUse the provided `Player#join(channelID)` method to join voice channels.\n\n```js\nawait player.join('channel id');\n```\n\nLoad a track and then pass it to the `Player#play` method to play something.\n\n```js\nconst res = await voice.load('ytsearch:monstercat');\nawait player.play(res.tracks[0]);\n```\n\nStop playback.\n\n```js\nawait player.stop();\n// or, to destroy the player entirely\nawait player.destroy();\n```\n\n### Events\n\nThe client and players are event emitters. Events will only get emitted on a player if the event has a guild ID. The client will always emit every event. Events are emitted with the name as the `op` property from the event; see the [lavalink implementation page](https://github.com/freyacodes/Lavalink/blob/master/IMPLEMENTATION.md#incoming-messages) for details on available events.\n\n```js\nvoice.players.get('guild id').on('event', (d) => {\n  console.log('track ended!', d);\n});\n\nvoice.on('event', (d) => {\n  console.log('track ended!', d);\n});\n```\n\n## Clustering\n\n```js\nconst { Cluster } = require('lavalink');\n\nconst cluster = new Cluster({\n  nodes: [\n    // node options here; see above\n  ],\n  send(guildID, packet) {\n    // send to gateway; same as for single node usage\n  },\n  filter(node, guildID) { // optional\n    // return a boolean indicating whether the given guild can be run on the given node\n    // useful for limiting guilds to specific nodes (for instance, if you setup lavalink edge servers to minimize latency)\n    // this must return true at least once for a given set of nodes, otherwise some methods may error\n  },\n});\n```\n\nWhen using a cluster, you can use the `Cluster#voiceStateUpdate` and `Cluster#voiceServerUpdate` methods to forward voice events (rather than those on `Node`), which will automatically route packets to the correct node.\n\nClusters have a `nodes` property which is an array of all connected nodes. See above documentation for details about how to use them. Clusters have a number of properties to make load balancing more convenient. For example, to get an array of nodes sorted by CPU load:\n\n```js\nconst recommendedNodes = cluster.sort();\n```\n\nAdditionally, nodes created as part of a cluster support a `tags: Set<string>` property, which can then be used in the above-mentioned `filter` method to easily separate guilds into specific nodes.\n\nClusters also have a shortcut method to avoid lengthy searches of all connected nodes for a specific player. `Cluster#get(guildID: string)` will return a player for a specified guild; if no player currently exists, it will create the player on the top recommended node.\n\n```js\nconst player = cluster.get(guildID);\n```\n\nPlayers can be moved to a new node by calling the `Player#moveTo(node: Node)` method. Note that this will stop the player and *not* restart it; you must restart the player manually.\n\n## Caveats\n\nThis library stores a minimum amount of state in memory that is required for it to be usable. This means that information such as node stats and player positions are not automatically tracked. In order to do so, you should listen to the event that provides the data and cache it yourself. See #15 for more information.\n\nAdditionally, this library does not currently support external caches to avoid unnecessary drag on the event loop. If you have a legitimate use case for this, feel free to open a discussion.\n\n## Reference\n\nSee the [Lavalink reference](https://github.com/freyacodes/Lavalink/blob/master/IMPLEMENTATION.md) for details.\n\n### `Player`\n\n- *readonly* `node: Node`\n- `guildID: string`\n- `status: Status`\n- *readonly* `playing: boolean`\n- *readonly* `paused: boolean`\n- *readonly* `voiceState: VoiceStateUpdate | undefined` - a partially reconstructed voice state update packet for this player\n- *readonly* `voiceServer: VoiceServerUpdate | undefined` - the latest voice server update packet for this player\n- `moveTo(node: Node): Promise<void>` - destroy the player and forward voice state to the specified node. *Warning:* will reject if no voice state data is available. The player must be manually restarted once it has moved.\n- `play(track: string | Track, { start?: number, end?: number } = {}): Promise<void>`\n- `setVolume(volume: number): Promise<void>`\n- `setEqualizer(bands: Array<{ band: number, gain: number}>): Promise<void>`\n- `seek(position: number): Promise<void>`\n- `pause(paused = true): Promise<void>`\n- `stop(): Promise<void>`\n- `destroy(): Promise<void>`\n- `join(channel: string, { deaf = false, mute = false } = {}): Promise<void>`\n\n```ts\nenum Status {\n  INSTANTIATED,\n  PLAYING,\n  PAUSED,\n  ENDED,\n  ERRORED,\n  STUCK\n}\n```\n\n### `Node`\n\n- `send(guildID: string, pk: object): Promise<void>`\n- `players: PlayerStore`\n- `voiceStates: Map<string, string>` - guild ID mapped to session ID\n- `voiceServers: Map<string, VoiceServerUpdate>`\n- `load(identifier: string): Promise<TrackResponse>`\n- `decode(track: string | string[]): Promise<TrackResponse | TrackResponse[]>`\n- `voiceStateUpdate(packet: VoiceStateUpdate): Promise<boolean>`\n- `voiceServerUpdate(packet: VoiceServerUpdate): Promise<boolean>`\n- `voiceStates: Map<string, string>`\n- `voiceServers: Map<string, VoiceServerUpdate>`\n- `connection?: Connection`\n- `http?: Http`\n- `password: string`\n- `userID: string`\n- `shardCount?: number`\n\n```ts\ninterface VoiceStateUpdate {\n  guild_id: string;\n  channel_id?: string;\n  user_id: string;\n  session_id: string;\n  deaf?: boolean;\n  mute?: boolean;\n  self_deaf?: boolean;\n  self_mute?: boolean;\n  suppress?: boolean;\n}\n\ninterface VoiceServerUpdate {\n  guild_id: string;\n  token: string;\n  endpoint: string;\n}\n\ninterface NodeOptions {\n  password: string;\n  userID: string;\n  shardCount?: number;\n  hosts?: {\n    rest?: string;\n    ws?: string | { url: string, options: WebSocket.ClientOptions };\n  };\n  host?: string;\n  send: (guild: string, pk: any) => Promise<any>;\n}\n```\n\n### Http\n\n- **`constructor(node: Node, input: string, base?: string)`**\n- *readonly* `node: Node`\n- `input: string` - passed to Node.js URL constructor\n- `base?: string` - passed to Node.js URL constructor\n- `url(): URL`\n- `load(identifier: string): Promise<TrackResponse[]>`\n- `decode(track: string): Promise<Track>`\n- `decode(tracks: string[]): Promise<Track[]>`\n\n```ts\nenum LoadType {\n  TRACK_LOADED = 'TRACK_LOADED',\n  PLAYLIST_LOADED = 'PLAYLIST_LOADED',\n  SEARCH_RESULT = 'SEARCH_RESULT',\n  NO_MATCHES = 'NO_MATCHES',\n  LOAD_FAILED = 'LOAD_FAILED'\n}\n\ninterface TrackResponse {\n  loadType: LoadType,\n  playlistInfo: PlaylistInfo,\n  tracks: Track[]\n}\n\ninterface TrackResponse {\n loadType: LoadType,\n playlistInfo: PlaylistInfo,\n tracks: Track[]\n}\n\ninterface PlaylistInfo {\n  name?: string,\n  selectedTrack?: number\n}\n\ninterface Track {\n  track: string;\n  info: {\n    identifier: string;\n    isSeekable: boolean;\n    author: string;\n    length: number;\n    isStream: boolean;\n    position: number;\n    title: string;\n    uri: string;\n  };\n}\n```\n\n### `Cluster`\n\n- **`constructor(options: ClusterOptions)`**\n- *readonly* `nodes: ClusterNode[]`\n- `send(guildID: string, pk: object): Promise<any>`\n- `filter(node: ClusterNode, guildID: string): boolean`\n- `spawn(options: ClusterNodeOptions): ClusterNode`\n- `spawn(options: ClusterNodeOptions[]): ClusterNode[]`\n- `sort(): ClusterNode[]` - does *not* sort in place\n- `getNode(guildID: string): Node` - throws if the node doesn't already exist and the filter never returns true\n- `has(guildID: string): boolean`\n- `get(guildID: string): Player`\n- `voiceStateUpdate(state: VoiceStateUpdate): Promise<boolean>`\n- `voiceServerUpdate(server: VoiceServerUpdate): Promise<boolean>`\n\n```ts\ninterface ClusterOptions {\n  send: (guildID: string, pk: object) => Promise<any>;\n  filter?: (node: ClusterNode, guildID: string) => boolean;\n  nodes?: ClusterNodeOptions;\n}\n```\n\n### `ClusterNode extends Node`\n\n- **`constructor(cluster: Cluster, options: ClusterNodeOptions)`**\n- `tags: Set<string>`\n- `stats?: Stats`\n\n```ts\ninterface Stats {\n  players: number;\n  playingPlayers: number;\n  uptime: number;\n  memory?: {\n    free: number;\n    used: number;\n    allocated: number;\n    reservable: number;\n  };\n  cpu?: {\n    cores: number;\n    systemLoad: number;\n    lavalinkLoad: number;\n  };\n  frameStats?: {\n    sent: number;\n    nulled: number;\n    deficit: number;\n  };\n}\n\ninterface ClusterNodeOptions extends NodeOptions {\n  tags?: Iterable<string>;\n}\n```\n\n## Discord.js example\n\n```js\nconst { Client } = require('discord.js');\nconst { Node } = require('lavalink');\n\nconst client = new Client();\nconst voice = new Node({\n  // options here\n  send(guildID, packet) {\n    if (client.guilds.has(guildID)) return client.ws.send(packet);\n    throw new Error('attempted to send a packet on the wrong shard');\n  }\n});\n\nclient.on('raw', pk => {\n  if (pk.t === 'VOICE_STATE_UPDATE') voice.voiceStateUpdate(pk.d);\n  if (pk.t === 'VOICE_SERVER_UPDATE') voice.voiceServerUpdate(pk.d);\n});\n```\n"
}